!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/bzhang523/Desktop/itap/itap/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
Array	wsq.hpp	/^    explicit Array(int64_t c) : $/;"	f	struct:WorkStealingQueue::Array
Array	wsq.hpp	/^  struct Array {$/;"	s	class:WorkStealingQueue
BLOCK_SIZE	partition_cuda.cu	/^#define BLOCK_SIZE /;"	d	file:
C	wsq.hpp	/^    int64_t C;$/;"	m	struct:WorkStealingQueue::Array	typeref:typename:int64_t
CEdge	itap.hpp	/^class CEdge{$/;"	c	namespace:itap
CNode	itap.hpp	/^class CNode {$/;"	c	namespace:itap
Edge	itap.hpp	/^class Edge {$/;"	c	namespace:itap
M	wsq.hpp	/^    int64_t M;$/;"	m	struct:WorkStealingQueue::Array	typeref:typename:int64_t
Node	itap.hpp	/^    Node(const std::string& name=""): _name(name) {}$/;"	f	class:itap::Node
Node	itap.hpp	/^class Node {$/;"	c	namespace:itap
S	wsq.hpp	/^    std::atomic<T>* S;$/;"	m	struct:WorkStealingQueue::Array	typeref:typename:std::atomic<T> *
THREADS_PREFER_PTHREAD_FLAG	CMakeLists.txt	/^set(THREADS_PREFER_PTHREAD_FLAG ON)$/;"	v
WorkStealingQueue	wsq.hpp	/^WorkStealingQueue<T>::WorkStealingQueue(int64_t c) {$/;"	f	class:WorkStealingQueue
WorkStealingQueue	wsq.hpp	/^class WorkStealingQueue {$/;"	c
__anon2e612ca40102	itap.cpp	/^      threads.emplace_back([this, i, &cluster_cnt, &max_cluster_id, &node_cnt, &queues, &num_thr/;"	f	function:itap::iTAP::_partition_cpu	file:
__anon2e612ca40202	itap.cpp	/^    node._task = taskflow.emplace([](){}).name(node._name + "[" + std::to_string(node._cluster_i/;"	f	function:itap::iTAP::dump_graph	file:
__anon2e612ca40302	itap.cpp	/^    node._task = taskflow.emplace([this, matrix_size]() {$/;"	f	function:itap::iTAP::run_graph	file:
__anon2e612ca40402	itap.cpp	/^    cnode._task = taskflow.emplace([&cnode, matrix_size](){$/;"	f	function:itap::iTAP::run_graph	file:
__anon2e612ca40502	itap.cpp	/^  taskflow.emplace([this, matrix_size] () {$/;"	f	function:itap::iTAP::run_graph	file:
_adjncy	itap.hpp	/^    std::vector<int> _adjncy; \/\/ flatterned adjacency list$/;"	m	class:itap::iTAP	typeref:typename:std::vector<int>
_adjncy_size	itap.hpp	/^    std::vector<int> _adjncy_size; \/\/ number of fanouts of each node$/;"	m	class:itap::iTAP	typeref:typename:std::vector<int>
_adjp	itap.hpp	/^    std::vector<int> _adjp; \/\/ edge offset $/;"	m	class:itap::iTAP	typeref:typename:std::vector<int>
_array	wsq.hpp	/^  std::atomic<Array*> _array;$/;"	m	class:WorkStealingQueue	typeref:typename:std::atomic<Array * >
_assign_cluster_id	itap.cpp	/^void iTAP::_assign_cluster_id(Node* node_ptr, std::vector<std::atomic<size_t>>& cluster_cnt, std/;"	f	class:itap::iTAP	typeref:typename:void
_bottom	wsq.hpp	/^  std::atomic<int64_t> _bottom;$/;"	m	class:WorkStealingQueue	typeref:typename:std::atomic<int64_t>
_candidates	itap.hpp	/^    std::vector<Node*> _candidates;$/;"	m	class:itap::iTAP	typeref:typename:std::vector<Node * >
_cedges	itap.hpp	/^    std::list<CEdge> _cedges;$/;"	m	class:itap::iTAP	typeref:typename:std::list<CEdge>
_cluster_cnt	itap.hpp	/^    std::vector<size_t> _cluster_cnt;$/;"	m	class:itap::iTAP	typeref:typename:std::vector<size_t>
_cluster_id	itap.hpp	/^    int _cluster_id = -1;$/;"	m	class:itap::Node	typeref:typename:int
_cnode	itap.hpp	/^    CNode* _cnode = NULL; \/\/ specify which cnode(cluster) this node belongs to$/;"	m	class:itap::Node	typeref:typename:CNode *
_cnode_satellite	itap.hpp	/^    std::list<CNode>::iterator _cnode_satellite;$/;"	m	class:itap::Node	typeref:typename:std::list<CNode>::iterator
_cnodes	itap.hpp	/^    std::list<CNode> _cnodes;$/;"	m	class:itap::iTAP	typeref:typename:std::list<CNode>
_csr_id	itap.hpp	/^    size_t _csr_id = 0; $/;"	m	class:itap::Node	typeref:typename:size_t
_dep_cnt	itap.hpp	/^    std::atomic<size_t> _dep_cnt{0};$/;"	m	class:itap::Node	typeref:typename:std::atomic<size_t>
_dep_cnt_random	itap.hpp	/^    size_t _dep_cnt_random = 0; \/\/ only for random_incre_ops()$/;"	m	class:itap::Node	typeref:typename:size_t
_dep_size	itap.hpp	/^    std::vector<int> _dep_size; \/\/ number of dependents of each node$/;"	m	class:itap::iTAP	typeref:typename:std::vector<int>
_desired_cluster_id	itap.hpp	/^    int _desired_cluster_id = -1; \/\/ for incremental partitioning$/;"	m	class:itap::Node	typeref:typename:int
_edges	itap.hpp	/^    std::list<Edge> _edges;$/;"	m	class:itap::iTAP	typeref:typename:std::list<Edge>
_export_csr	itap.cpp	/^void iTAP::_export_csr() {$/;"	f	class:itap::iTAP	typeref:typename:void
_fanin_satellites	itap.hpp	/^    std::list<std::pair<Node*, std::list<Edge*>::iterator>> _fanin_satellites;$/;"	m	class:itap::Node	typeref:typename:std::list<std::pair<Node *,std::list<Edge * >::iterator>>
_fanins	itap.hpp	/^    std::list<CEdge*> _fanins;$/;"	m	class:itap::CNode	typeref:typename:std::list<CEdge * >
_fanins	itap.hpp	/^    std::list<Edge*> _fanins;$/;"	m	class:itap::Node	typeref:typename:std::list<Edge * >
_fanout_satellites	itap.hpp	/^    std::list<std::pair<Node*, std::list<Edge*>::iterator>> _fanout_satellites;$/;"	m	class:itap::Node	typeref:typename:std::list<std::pair<Node *,std::list<Edge * >::iterator>>
_fanouts	itap.hpp	/^    std::list<CEdge*> _fanouts;$/;"	m	class:itap::CNode	typeref:typename:std::list<CEdge * >
_fanouts	itap.hpp	/^    std::list<Edge*> _fanouts;$/;"	m	class:itap::Node	typeref:typename:std::list<Edge * >
_from	itap.hpp	/^    CNode* _from;$/;"	m	class:itap::CEdge	typeref:typename:CNode *
_from	itap.hpp	/^    Node* _from;$/;"	m	class:itap::Edge	typeref:typename:Node *
_from_node	itap.hpp	/^    Node* _from_node;$/;"	m	class:itap::CEdge	typeref:typename:Node *
_from_satellite	itap.hpp	/^    std::list<Edge*>::iterator _from_satellite; \/\/ edge satellite in from node _fanouts$/;"	m	class:itap::Edge	typeref:typename:std::list<Edge * >::iterator
_frontiers	itap.hpp	/^    std::vector<Node*> _frontiers;$/;"	m	class:itap::iTAP	typeref:typename:std::vector<Node * >
_garbage	wsq.hpp	/^  std::vector<Array*> _garbage;$/;"	m	class:WorkStealingQueue	typeref:typename:std::vector<Array * >
_get_Lpd	itap.hpp	/^    int _get_Lpd(Node* node) {$/;"	f	class:itap::iTAP	typeref:typename:int
_get_Sps	itap.hpp	/^    int _get_Sps(Node* node) {$/;"	f	class:itap::iTAP	typeref:typename:int
_get_name	itap.hpp	/^    std::string _get_name() const {$/;"	f	class:itap::CNode	typeref:typename:std::string
_instack	itap.hpp	/^    bool _instack {false};$/;"	m	class:itap::CNode	typeref:typename:bool
_instack	itap.hpp	/^    bool _instack {false};$/;"	m	class:itap::Node	typeref:typename:bool
_isCyclicUtil	itap.cpp	/^bool iTAP::_isCyclicUtil(T node) {$/;"	f	class:itap::iTAP	typeref:typename:bool
_is_candidate	itap.hpp	/^    bool _is_candidate = true; $/;"	m	class:itap::Node	typeref:typename:bool
_is_frontier	itap.hpp	/^    bool _is_frontier = false;$/;"	m	class:itap::Node	typeref:typename:bool
_max_cluster_id	itap.hpp	/^    int _max_cluster_id;$/;"	m	class:itap::iTAP	typeref:typename:int
_name	itap.hpp	/^    std::string _name;$/;"	m	class:itap::Node	typeref:typename:std::string
_node_satellite	itap.hpp	/^    std::list<Node>::iterator _node_satellite;$/;"	m	class:itap::Node	typeref:typename:std::list<Node>::iterator
_nodes	itap.hpp	/^    std::list<Node*> _nodes;$/;"	m	class:itap::CNode	typeref:typename:std::list<Node * >
_nodes	itap.hpp	/^    std::list<Node> _nodes;$/;"	m	class:itap::iTAP	typeref:typename:std::list<Node>
_num_clusters	itap.hpp	/^    size_t _num_clusters = 0; $/;"	m	class:itap::iTAP	typeref:typename:size_t
_overflow	itap.hpp	/^    size_t _overflow = 0;$/;"	m	class:itap::iTAP	typeref:typename:size_t
_partition_cpu	itap.cpp	/^void iTAP::_partition_cpu() {$/;"	f	class:itap::iTAP	typeref:typename:void
_partition_cuda	partition_cuda.cu	/^void iTAP::_partition_cuda() {$/;"	f	typeref:typename:void iTAP::
_partition_size	itap.hpp	/^    size_t _partition_size = 1;$/;"	m	class:itap::iTAP	typeref:typename:size_t
_partitioned	itap.hpp	/^    bool _partitioned = false;$/;"	m	class:itap::Node	typeref:typename:bool
_partitioned	itap.hpp	/^    bool _partitioned = false;$/;"	m	class:itap::iTAP	typeref:typename:bool
_remove	itap.hpp	/^    bool _remove = false;$/;"	m	class:itap::Node	typeref:typename:bool
_satellite	itap.hpp	/^    std::list<CEdge>::iterator _satellite;$/;"	m	class:itap::CEdge	typeref:typename:std::list<CEdge>::iterator
_satellite	itap.hpp	/^    std::list<CNode>::iterator _satellite;$/;"	m	class:itap::CNode	typeref:typename:std::list<CNode>::iterator
_satellite	itap.hpp	/^    std::list<Edge>::iterator _satellite;$/;"	m	class:itap::Edge	typeref:typename:std::list<Edge>::iterator
_task	itap.hpp	/^    tf::Task _task;$/;"	m	class:itap::CNode	typeref:typename:tf::Task
_task	itap.hpp	/^    tf::Task _task;$/;"	m	class:itap::Node	typeref:typename:tf::Task
_to	itap.hpp	/^    CNode* _to;$/;"	m	class:itap::CEdge	typeref:typename:CNode *
_to	itap.hpp	/^    Node* _to;$/;"	m	class:itap::Edge	typeref:typename:Node *
_to_node	itap.hpp	/^    Node* _to_node;$/;"	m	class:itap::CEdge	typeref:typename:Node *
_to_satellite	itap.hpp	/^    std::list<Edge*>::iterator _to_satellite; \/\/ edge satellite in to node _fanins $/;"	m	class:itap::Edge	typeref:typename:std::list<Edge * >::iterator
_top	wsq.hpp	/^  std::atomic<int64_t> _top;$/;"	m	class:WorkStealingQueue	typeref:typename:std::atomic<int64_t>
_type1	itap.hpp	/^    bool _type1 = false;$/;"	m	class:itap::Node	typeref:typename:bool
_type2	itap.hpp	/^    bool _type2 = false;$/;"	m	class:itap::Node	typeref:typename:bool
_type3	itap.hpp	/^    bool _type3 = false;$/;"	m	class:itap::Node	typeref:typename:bool
_visited	itap.hpp	/^    bool _visited {false}; $/;"	m	class:itap::CNode	typeref:typename:bool
_visited	itap.hpp	/^    bool _visited {false}; $/;"	m	class:itap::Node	typeref:typename:bool
build_cluster_graph	itap.cpp	/^void iTAP::build_cluster_graph() {$/;"	f	class:itap::iTAP	typeref:typename:void
capacity	wsq.hpp	/^    int64_t capacity() const noexcept {$/;"	f	struct:WorkStealingQueue::Array	typeref:typename:int64_t
capacity	wsq.hpp	/^int64_t WorkStealingQueue<T>::capacity() const noexcept {$/;"	f	class:WorkStealingQueue	typeref:typename:int64_t
checkError_t	partition_cuda.cu	/^void checkError_t(cudaError_t error, std::string msg) {$/;"	f	typeref:typename:void
check_cluster	itap.cpp	/^void iTAP::check_cluster() const {$/;"	f	class:itap::iTAP	typeref:typename:void
dump_graph	itap.cpp	/^void iTAP::dump_graph() {$/;"	f	class:itap::iTAP	typeref:typename:void
empty	wsq.hpp	/^bool WorkStealingQueue<T>::empty() const noexcept {$/;"	f	class:WorkStealingQueue	typeref:typename:bool
generate_random_nums	itap.cpp	/^std::vector<size_t> iTAP::generate_random_nums(int N, int count) {$/;"	f	class:itap::iTAP	typeref:typename:std::vector<size_t>
get_imbalanced_factor	itap.cpp	/^double iTAP::get_imbalanced_factor() const{$/;"	f	class:itap::iTAP	typeref:typename:double
get_max_cluster_size	itap.cpp	/^size_t iTAP::get_max_cluster_size() const{$/;"	f	class:itap::iTAP	typeref:typename:size_t
has_cycle_post_partition	itap.cpp	/^bool iTAP::has_cycle_post_partition() {$/;"	f	class:itap::iTAP	typeref:typename:bool
has_cycle_pre_partition	itap.cpp	/^bool iTAP::has_cycle_pre_partition() {$/;"	f	class:itap::iTAP	typeref:typename:bool
has_fanin	itap.hpp	/^    bool has_fanin(Edge* edge) const {$/;"	f	class:itap::Node	typeref:typename:bool
has_fanout	itap.hpp	/^    bool has_fanout(Edge* edge) const {$/;"	f	class:itap::Node	typeref:typename:bool
iTAP	itap.cpp	/^iTAP::iTAP(const std::string& filename) {$/;"	f	class:itap::iTAP
iTAP	itap.hpp	/^    iTAP() {}$/;"	f	class:itap::iTAP
iTAP	itap.hpp	/^class iTAP {$/;"	c	namespace:itap
insert_edge	itap.cpp	/^Edge* iTAP::insert_edge(Node* from, Node* to) {$/;"	f	class:itap::iTAP	typeref:typename:Edge *
insert_node	itap.cpp	/^Node* iTAP::insert_node(const std::string& name) {$/;"	f	class:itap::iTAP	typeref:typename:Node *
is_cluster_cnt_valid	itap.cpp	/^bool iTAP::is_cluster_cnt_valid() const{$/;"	f	class:itap::iTAP	typeref:typename:bool
is_partition_valid	itap.cpp	/^bool iTAP::is_partition_valid() {$/;"	f	class:itap::iTAP	typeref:typename:bool
itap	CMakeLists.txt	/^add_library(itap itap.cpp partition_cuda.cu)$/;"	t
itap	itap.cpp	/^namespace itap{$/;"	n	file:
itap	itap.hpp	/^namespace itap {$/;"	n
num_fanins	itap.hpp	/^    size_t num_fanins() const {$/;"	f	class:itap::Node	typeref:typename:size_t
num_fanouts	itap.hpp	/^    size_t num_fanouts() const {$/;"	f	class:itap::Node	typeref:typename:size_t
num_nodes	itap.hpp	/^    size_t num_nodes() const {$/;"	f	class:itap::iTAP	typeref:typename:size_t
partition	itap.cpp	/^void iTAP::partition(bool incremental) {$/;"	f	class:itap::iTAP	typeref:typename:void
partition_gpu	partition_cuda.cu	/^__global__ void partition_gpu($/;"	f	typeref:typename:void
pop	wsq.hpp	/^    T pop(int64_t i) noexcept {$/;"	f	struct:WorkStealingQueue::Array	typeref:typename:T
pop	wsq.hpp	/^std::optional<T> WorkStealingQueue<T>::pop() {$/;"	f	class:WorkStealingQueue	typeref:typename:std::optional<T>
push	wsq.hpp	/^    void push(int64_t i, O&& o) noexcept {$/;"	f	struct:WorkStealingQueue::Array	typeref:typename:void
push	wsq.hpp	/^void WorkStealingQueue<T>::push(O&& o) {$/;"	f	class:WorkStealingQueue	typeref:typename:void
random_incre_ops	itap.cpp	/^void iTAP::random_incre_ops(size_t N) {$/;"	f	class:itap::iTAP	typeref:typename:void
remove_edge	itap.cpp	/^void iTAP::remove_edge(Edge* edge) {$/;"	f	class:itap::iTAP	typeref:typename:void
remove_node	itap.cpp	/^void iTAP::remove_node(Node* node) {$/;"	f	class:itap::iTAP	typeref:typename:void
reset_partition	itap.cpp	/^void iTAP::reset_partition() {$/;"	f	class:itap::iTAP	typeref:typename:void
resize	wsq.hpp	/^    Array* resize(int64_t b, int64_t t) {$/;"	f	struct:WorkStealingQueue::Array	typeref:typename:Array *
run_graph	itap.cpp	/^void iTAP::run_graph() {$/;"	f	class:itap::iTAP	typeref:typename:void
set_partition_size	itap.cpp	/^void iTAP::set_partition_size(const size_t partition_size) {$/;"	f	class:itap::iTAP	typeref:typename:void
size	wsq.hpp	/^size_t WorkStealingQueue<T>::size() const noexcept {$/;"	f	class:WorkStealingQueue	typeref:typename:size_t
steal	wsq.hpp	/^std::optional<T> WorkStealingQueue<T>::steal() {$/;"	f	class:WorkStealingQueue	typeref:typename:std::optional<T>
~Array	wsq.hpp	/^    ~Array() {$/;"	f	struct:WorkStealingQueue::Array
~WorkStealingQueue	wsq.hpp	/^WorkStealingQueue<T>::~WorkStealingQueue() {$/;"	f	class:WorkStealingQueue
